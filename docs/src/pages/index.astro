---
import CodeBlock from "@/components/code-block.astro";
import InstallCommands from "@/components/install-commands.astro";
import Layout from "@/layouts/layout.astro";
---

<Layout class="flex-1 overflow-y-auto">
  <main class="container my-6 max-w-5xl">
    <section class="space-y-6">
      <h1
        class="scroll-m-20 text-4xl font-extrabold tracking-tight lg:text-5xl"
      >
        Remeda
      </h1>

      <p class="text-xl text-muted-foreground">
        The first "data-first" and "data-last" utility library designed
        specifically for TypeScript
      </p>
      <InstallCommands />
    </section>

    <div class="mt-20 space-y-16">
      <section>
        <h2
          class="scroll-m-20 border-b pb-2 text-3xl font-semibold tracking-tight first:mt-0"
        >
          Why?
        </h2>

        <p
          class="max-w-prose leading-7 [&:not(:first-child)]:mt-6 [&:not(:last-child)]:mb-6"
        >
          There are no good utility libraries that work well with TypeScript.
          When working with Lodash or Ramda you have to annotate types manually
          most of the time. Remeda is written and tested in TypeScript and that
          means there won't be any problems with custom typings.
        </p>
      </section>

      <section>
        <h2
          class="scroll-m-20 border-b pb-2 text-3xl font-semibold tracking-tight first:mt-0"
        >
          What's "data-first" and "data-last"?
        </h2>

        <p
          class="max-w-prose leading-7 [&:not(:first-child)]:mt-6 [&:not(:last-child)]:mb-6"
        >
          Functional programming is nice, and it makes the code more readable.
          However there are situations where you don't need "pipes", and you
          want to call just a single function.
        </p>

        <CodeBlock
          code=`
// Remeda
R.pick(obj, ['firstName', 'lastName']);

// Ramda
R.pick(['firstName', 'lastName'], obj);

// Lodash
_.pick(obj, ['firstName', 'lastName']);`
        />

        <p
          class="max-w-prose leading-7 [&:not(:first-child)]:mt-6 [&:not(:last-child)]:mb-6"
        >
          For readers looking for data-last forms like
          <code>R.filter(fn)(array)</code>, Remeda supports it. Keep reading
          along!
        </p>

        <p
          class="max-w-prose leading-7 [&:not(:first-child)]:mt-6 [&:not(:last-child)]:mb-6"
        >
          In the above example, "data-first" approach is more natural and more
          programmer friendly because when you type the second argument, you get
          the auto-complete from the IDE. It's not possible to get the
          auto-complete in Ramda because the data argument is not provided.
        </p>

        <p
          class="max-w-prose leading-7 [&:not(:first-child)]:mt-6 [&:not(:last-child)]:mb-6"
        >
          "data-last" approach is helpful when writing data transformations aka
          pipes.
        </p>

        <CodeBlock
          code=`
const users = [
  { name: 'john', age: 20, gender: 'm' },
  { name: 'marry', age: 22, gender: 'f' },
  { name: 'samara', age: 24, gender: 'f' },
  { name: 'paula', age: 24, gender: 'f' },
  { name: 'bill', age: 33, gender: 'm' },
];

// Remeda
R.pipe(
  users,
  R.filter(x => x.gender === 'f'),
  R.groupBy(x => x.age),
);

// Ramda
R.pipe(
  R.filter(x => x.gender === 'f'),
  R.groupBy(x => x.age),
)(users); // broken typings in TS :(

// Lodash
_(users)
  .filter(x => x.gender === 'f')
  .groupBy(x => x.age)
  .value();

// Lodash-fp
_.flow(
  _.filter(x => x.gender === 'f'),
  _.groupBy(x => x.age),
)(users); // broken typings in TS :(`
        />

        <p
          class="max-w-prose leading-7 [&:not(:first-child)]:mt-6 [&:not(:last-child)]:mb-6"
        >
          Mixing paradigms can be cumbersome in Lodash because it requires
          importing two different methods. Remeda implements all methods in two
          versions, and the correct overload is picked based on the number of
          provided arguments. The "data-last" version must always have one
          argument less than the "data-first" version.
        </p>

        <CodeBlock
          code=`
// Remeda
R.pick(obj, ['firstName', 'lastName']); // data-first
R.pipe(obj, R.pick(['firstName', 'lastName'])); // data-last

R.pick(['firstName', 'lastName'], obj); // error, this won't work!
R.pick(['firstName', 'lastName'])(obj); // this will work but the types cannot be inferred`
        />
      </section>

      <section>
        <h2
          class="scroll-m-20 border-b pb-2 text-3xl font-semibold tracking-tight first:mt-0"
        >
          Lazy evaluation
        </h2>

        <p
          class="max-w-prose leading-7 [&:not(:first-child)]:mt-6 [&:not(:last-child)]:mb-6"
        >
          Many functions support lazy evaluation when using <code>pipe</code> or
          <code>piped</code>. These functions have a <code>pipeable</code> tag in
          the documentation.
        </p>

        <p
          class="max-w-prose leading-7 [&:not(:first-child)]:mt-6 [&:not(:last-child)]:mb-6"
        >
          Lazy evaluation is not supported in Ramda and only partially supported
          in lodash.
        </p>

        <CodeBlock
          code=`
// Get first 3 unique values
const arr = [1, 2, 2, 3, 3, 4, 5, 6];

const result = R.pipe(
  arr,
  R.map(x => {
    console.log('iterate', x);
    return x;
  }),
  R.uniq(),
  R.take(3)
); // => [1, 2, 3]

/**
 * Console output:
 * iterate 1
 * iterate 2
 * iterate 2
 * iterate 3
 */
       `
        />
      </section>
    </div>
  </main>
</Layout>
