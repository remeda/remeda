---
import { Badge } from "@/components/ui/badge";
import { CardTitle } from "@/components/ui/card";
import type { functionsCollectionName } from "@/content/functions/content.config";
import { extractTags } from "@/lib/tags";
import type { InferEntrySchema } from "astro:content";
import { hasAtLeast } from "remeda";
import GithubSource from "./github-source.astro";
import Markdown from "./markdown.astro";
import Prose from "./prose.astro";
import { TagBadge } from "./tag-badge";
import invariant from "tiny-invariant";

type Props = {
  readonly func: InferEntrySchema<typeof functionsCollectionName>;
  readonly internalNames: ReadonlySet<string>;
  readonly category: string | undefined;
};

const { func, category, internalNames } = Astro.props;

invariant(
  func.kind === "function",
  `Entry ${func.name} is of unsupported kind: ${func.kind}`,
);

const {
  name,
  signatures: [
    {
      comment: { blockTags, summary },
    },
  ],
  sources,
} = func;
---

<>
  <div class="flex items-center gap-2">
    <CardTitle className="flex-1 overflow-hidden text-2xl">
      {name}
    </CardTitle>
    {
      extractTags(blockTags).map((tag) => (
        <TagBadge tag={tag} className="h-8" />
      ))
    }
    <Badge className="hidden h-8 sm:flex">{category}</Badge>
    {hasAtLeast(sources, 1) && <GithubSource url={sources[0].url} />}
  </div>
  {
    hasAtLeast(summary, 1) && (
      <Prose>
        <Markdown
          markdown={summary
            .map(({ kind, text }) => {
              if (kind !== "code") {
                return text;
              }

              const codeContent = text.slice(1, -1);
              if (!internalNames.has(codeContent)) {
                return text;
              }

              // If this is a function name, link to its anchor:
              return `[${text}](#${codeContent})`;
            })
            .join("")}
        />
      </Prose>
    )
  }
</>
