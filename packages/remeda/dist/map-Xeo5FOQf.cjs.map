{"version":3,"file":"map-Xeo5FOQf.cjs","names":["purry"],"sources":["../src/map.ts"],"sourcesContent":["import type { IterableContainer } from \"./internal/types/IterableContainer\";\nimport type { LazyEvaluator } from \"./internal/types/LazyEvaluator\";\nimport type { Mapped } from \"./internal/types/Mapped\";\nimport { purry } from \"./purry\";\n\n/**\n * Creates a new array populated with the results of calling a provided function\n * on every element in the calling array. Equivalent to `Array.prototype.map`.\n *\n * @param data - The array to map.\n * @param callbackfn - A function to execute for each element in the array. Its\n * return value is added as a single element in the new array.\n * @returns A new array with each element being the result of the callback\n * function.\n * @signature\n *    R.map(data, callbackfn)\n * @example\n *    R.map([1, 2, 3], R.multiply(2)); // => [2, 4, 6]\n *    R.map([0, 0], R.add(1)); // => [1, 1]\n *    R.map([0, 0], (value, index) => value + index); // => [0, 1]\n * @dataFirst\n * @lazy\n * @category Array\n */\nexport function map<T extends IterableContainer, U>(\n  data: T,\n  callbackfn: (value: T[number], index: number, data: T) => U,\n): Mapped<T, U>;\n\n/**\n * Creates a new array populated with the results of calling a provided function\n * on every element in the calling array. Equivalent to `Array.prototype.map`.\n *\n * @param callbackfn - A function to execute for each element in the array. Its\n * return value is added as a single element in the new array.\n * @returns A new array with each element being the result of the callback\n * function.\n * @signature\n *    R.map(callbackfn)(data)\n * @example\n *    R.pipe([1, 2, 3], R.map(R.multiply(2))); // => [2, 4, 6]\n *    R.pipe([0, 0], R.map(R.add(1))); // => [1, 1]\n *    R.pipe([0, 0], R.map((value, index) => value + index)); // => [0, 1]\n * @dataLast\n * @lazy\n * @category Array\n */\nexport function map<T extends IterableContainer, U>(\n  callbackfn: (value: T[number], index: number, data: T) => U,\n): (data: T) => Mapped<T, U>;\n\nexport function map(...args: ReadonlyArray<unknown>): unknown {\n  return purry(mapImplementation, args, lazyImplementation);\n}\n\nconst mapImplementation = <T, U>(\n  data: ReadonlyArray<T>,\n  callbackfn: (value: T, index: number, data: ReadonlyArray<T>) => U,\n): Array<U> => data.map(callbackfn);\n\nconst lazyImplementation =\n  <T, U>(\n    callbackfn: (value: T, index: number, data: ReadonlyArray<T>) => U,\n  ): LazyEvaluator<T, U> =>\n  (value, index, data) => ({\n    done: false,\n    hasNext: true,\n    next: callbackfn(value, index, data),\n  });\n"],"mappings":"wCAmDA,SAAgB,EAAI,GAAG,EAAuC,CAC5D,OAAOA,EAAAA,EAAM,EAAmB,EAAM,EAAmB,CAG3D,MAAM,GACJ,EACA,IACa,EAAK,IAAI,EAAW,CAE7B,EAEF,IAED,EAAO,EAAO,KAAU,CACvB,KAAM,GACN,QAAS,GACT,KAAM,EAAW,EAAO,EAAO,EAAK,CACrC"}