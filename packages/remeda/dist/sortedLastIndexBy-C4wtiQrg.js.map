{"version":3,"file":"sortedLastIndexBy-C4wtiQrg.js","names":[],"sources":["../src/sortedLastIndexBy.ts"],"sourcesContent":["import { purry } from \"./purry\";\nimport { binarySearchCutoffIndex } from \"./internal/binarySearchCutoffIndex\";\n\n/**\n * Find the insertion position (index) of an item in an array with items sorted\n * in ascending order using a value function; so that\n * `splice(sortedIndex, 0, item)` would result in maintaining the arrays sort-\n * ness. The array can contain duplicates.\n * If the item already exists in the array the index would be of the *last*\n * occurrence of the item.\n *\n * Runs in O(logN) time.\n *\n * See also:\n * * `findIndex` - scans a possibly unsorted array in-order (linear search).\n * * `sortedLastIndex` - a simplified version of this function, without a callbackfn.\n * * `sortedIndexBy` - like this function, but returns the first suitable index.\n * * `sortedIndex` - like `sortedLastIndex` but without a callbackfn.\n * * `rankBy` - scans a possibly unsorted array in-order, returning the index based on a sorting criteria.\n *\n * @param data - The (ascending) sorted array.\n * @param item - The item to insert.\n * @param valueFunction - All comparisons would be performed on the result of\n * calling this function on each compared item. Preferably this function should\n * return a `number` or `string`. This function should be the same as the one\n * provided to sortBy to sort the array. The function is called exactly once on\n * each items that is compared against in the array, and once at the beginning\n * on `item`. When called on `item` the `index` argument is `undefined`.\n * @returns Insertion index (In the range 0..data.length).\n * @signature\n *    R.sortedLastIndexBy(data, item, valueFunction)\n * @example\n *    R.sortedLastIndexBy([{age:20},{age:22}],{age:21},prop('age')) // => 1\n * @dataFirst\n * @category Array\n */\nexport function sortedLastIndexBy<T>(\n  data: ReadonlyArray<T>,\n  item: T,\n  valueFunction: (\n    item: T,\n    index: number | undefined,\n    data: ReadonlyArray<T>,\n  ) => NonNullable<unknown>,\n): number;\n\n/**\n * Find the insertion position (index) of an item in an array with items sorted\n * in ascending order using a value function; so that\n * `splice(sortedIndex, 0, item)` would result in maintaining the arrays sort-\n * ness. The array can contain duplicates.\n * If the item already exists in the array the index would be of the *last*\n * occurrence of the item.\n *\n * Runs in O(logN) time.\n *\n * See also:\n * * `findIndex` - scans a possibly unsorted array in-order (linear search).\n * * `sortedLastIndex` - a simplified version of this function, without a callbackfn.\n * * `sortedIndexBy` - like this function, but returns the first suitable index.\n * * `sortedIndex` - like `sortedLastIndex` but without a callbackfn.\n * * `rankBy` - scans a possibly unsorted array in-order, returning the index based on a sorting criteria.\n *\n * @param item - The item to insert.\n * @param valueFunction - All comparisons would be performed on the result of\n * calling this function on each compared item. Preferably this function should\n * return a `number` or `string`. This function should be the same as the one\n * provided to sortBy to sort the array. The function is called exactly once on\n * each items that is compared against in the array, and once at the beginning\n * on `item`. When called on `item` the `index` argument is `undefined`.\n * @returns Insertion index (In the range 0..data.length).\n * @signature\n *    R.sortedLastIndexBy(item, valueFunction)(data)\n * @example\n *    R.pipe([{age:20},{age:22}],sortedLastIndexBy({age:21},prop('age'))) // => 1\n * @dataLast\n * @category Array\n * @see sortedIndex, sortedIndexBy, sortedIndexWith, sortedLastIndex\n */\nexport function sortedLastIndexBy<T>(\n  item: T,\n  valueFunction: (\n    item: T,\n    index: number | undefined,\n    data: ReadonlyArray<T>,\n  ) => NonNullable<unknown>,\n): (data: ReadonlyArray<T>) => number;\n\nexport function sortedLastIndexBy(...args: ReadonlyArray<unknown>): unknown {\n  return purry(sortedLastIndexByImplementation, args);\n}\n\nfunction sortedLastIndexByImplementation<T>(\n  array: ReadonlyArray<T>,\n  item: T,\n  valueFunction: (\n    item: T,\n    index: number | undefined,\n    data: ReadonlyArray<T>,\n  ) => NonNullable<unknown>,\n): number {\n  const value = valueFunction(item, undefined /* index */, array);\n  return binarySearchCutoffIndex(\n    array,\n    // The only difference between the regular implementation and the \"last\"\n    // variation is that we consider the pivot with equality too, so that we\n    // skip all equal values in addition to the lower ones.\n    (pivot, index) => valueFunction(pivot, index, array) <= value,\n  );\n}\n"],"mappings":"6FAwFA,SAAgB,EAAkB,GAAG,EAAuC,CAC1E,OAAO,EAAM,EAAiC,EAAK,CAGrD,SAAS,EACP,EACA,EACA,EAKQ,CACR,IAAM,EAAQ,EAAc,EAAM,IAAA,GAAuB,EAAM,CAC/D,OAAO,EACL,GAIC,EAAO,IAAU,EAAc,EAAO,EAAO,EAAM,EAAI,EACzD"}