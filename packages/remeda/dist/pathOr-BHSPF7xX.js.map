{"version":3,"file":"pathOr-BHSPF7xX.js","names":[],"sources":["../src/pathOr.ts"],"sourcesContent":["/* eslint-disable jsdoc/require-param, jsdoc/require-example, jsdoc/require-description -- allow us to deprecate all overloads of the function, not just those that have the docblock directly above them. */\n\nimport { purry } from \"./purry\";\n\n/**\n * Given a union of indexable types `T`, we derive an indexable type\n * containing all of the keys of each variant of `T`. If a key is\n * present in multiple variants of `T`, then the corresponding type in\n * `Pathable<T>` will be the intersection of all types for that key.\n *\n * @example\n *    type T1 = Pathable<{a: number} | {a: string; b: boolean}>\n *    // {a: number | string; b: boolean}\n *\n *    type T2 = Pathable<{a?: {b: string}}\n *    // {a: {b: string} | undefined}\n *\n *    type T3 = Pathable<{a: string} | number>\n *    // {a: string}\n *\n *    type T4 = Pathable<{a: number} | {a: string} | {b: boolean}>\n *    // {a: number | string; b: boolean}\n *\n * This type lets us answer the questions:\n * - Given some object of type `T`, what keys might this object have?\n * - If this object did happen to have a particular key, what values\n *   might that key have?\n */\ntype Pathable<T> = { [K in AllKeys<T>]: TypesForKey<T, K> };\n\ntype AllKeys<T> = T extends infer I ? keyof I : never;\ntype TypesForKey<T, K extends PropertyKey> = T extends infer I\n  ? K extends keyof I\n    ? I[K]\n    : never\n  : never;\n\n// Like Required<T>, but also removes explicit null and undefined typings */\ntype StrictlyRequired<T> = { [K in keyof T]-?: NonNullable<T[K]> };\n\n/**\n * Given some `A` which is a key of at least one variant of `T`, derive\n * `T[A]` for the cases where `A` is present in `T`, and `T[A]` is not\n * null or undefined.\n */\ntype PathValue1<T, A extends keyof Pathable<T>> = StrictlyRequired<\n  Pathable<T>\n>[A];\n/** All possible options after successfully reaching `T[A]`. */\ntype Pathable1<T, A extends keyof Pathable<T>> = Pathable<PathValue1<T, A>>;\n\n/** As `PathValue1`, but for `T[A][B]`. */\ntype PathValue2<\n  T,\n  A extends keyof Pathable<T>,\n  B extends keyof Pathable1<T, A>,\n> = StrictlyRequired<Pathable1<T, A>>[B];\n/** As `Pathable1`, but for `T[A][B]`. */\ntype Pathable2<\n  T,\n  A extends keyof Pathable<T>,\n  B extends keyof Pathable1<T, A>,\n> = Pathable<PathValue2<T, A, B>>;\n\n/** As `PathValue1`, but for `T[A][B][C]`. */\ntype PathValue3<\n  T,\n  A extends keyof Pathable<T>,\n  B extends keyof Pathable1<T, A>,\n  C extends keyof Pathable2<T, A, B>,\n> = StrictlyRequired<Pathable2<T, A, B>>[C];\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is `null` or `undefined`, the `defaultValue` is returned in its place.\n *\n * **DEPRECATED**: Use `defaultTo(prop(object, ...path), defaultValue)`\n * instead!\n *\n * @param object - The target object.\n * @param path - The path of the property to get.\n * @param defaultValue - The default value.\n * @signature R.pathOr(object, array, defaultValue)\n * @example\n *    R.pathOr({x: 10}, ['y'], 2) // 2\n *    R.pathOr({y: 10}, ['y'], 2) // 10\n * @dataFirst\n * @category Object\n * @deprecated Use `defaultTo(prop(object, ...path), defaultValue)` instead.\n */\nexport function pathOr<T, A extends keyof Pathable<T>>(\n  object: T,\n  path: readonly [A],\n  defaultValue: PathValue1<T, A>,\n): PathValue1<T, A>;\n\n/**\n * @deprecated Use `defaultTo(prop(object, ...path), defaultValue)` instead.\n */\nexport function pathOr<\n  T,\n  A extends keyof Pathable<T>,\n  B extends keyof Pathable1<T, A>,\n>(\n  object: T,\n  path: readonly [A, B],\n  defaultValue: PathValue2<T, A, B>,\n): PathValue2<T, A, B>;\n\n/**\n * @deprecated Use `defaultTo(prop(object, ...path), defaultValue)` instead.\n */\nexport function pathOr<\n  T,\n  A extends keyof Pathable<T>,\n  B extends keyof Pathable1<T, A>,\n  C extends keyof Pathable2<T, A, B>,\n>(\n  object: T,\n  path: readonly [A, B, C],\n  defaultValue: PathValue3<T, A, B, C>,\n): PathValue3<T, A, B, C>;\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is `undefined`, the `defaultValue` is returned in its place.\n *\n * **DEPRECATED**: Use `($) => defaultTo(prop($, ...path), defaultValue)`\n * instead, or if already inside a `pipe`, replace the call to `pathOr` with:\n * `pipe(..., prop(...path), defaultTo(defaultValue), ...)`.\n *\n * @param path - The path of the property to get.\n * @param defaultValue - The default value.\n * @signature R.pathOr(array, defaultValue)(object)\n * @example\n *    R.pipe({x: 10}, R.pathOr(['y'], 2)) // 2\n *    R.pipe({y: 10}, R.pathOr(['y'], 2)) // 10\n * @dataLast\n * @category Object\n * @deprecated Use `($) => defaultTo(prop($, ...path), defaultValue)` instead,\n * or if already inside a `pipe`, replace the call to `pathOr` with:\n * `pipe(..., prop(...path), defaultTo(defaultValue), ...)`.\n */\nexport function pathOr<T, A extends keyof Pathable<T>>(\n  path: readonly [A],\n  defaultValue: PathValue1<T, A>,\n): (object: T) => PathValue1<T, A>;\n\n/**\n * @deprecated Use `($) => defaultTo(prop($, ...path), defaultValue)` instead,\n * or if already inside a `pipe`, replace the call to `pathOr` with:\n * `pipe(..., prop(...path), defaultTo(defaultValue), ...)`.\n */\nexport function pathOr<\n  T,\n  A extends keyof Pathable<T>,\n  B extends keyof Pathable1<T, A>,\n>(\n  path: readonly [A, B],\n  defaultValue: PathValue2<T, A, B>,\n): (object: T) => PathValue2<T, A, B>;\n\n/**\n * @deprecated Use `($) => defaultTo(prop($, ...path), defaultValue)` instead,\n * or if already inside a `pipe`, replace the call to `pathOr` with:\n * `pipe(..., prop(...path), defaultTo(defaultValue), ...)`.\n */\nexport function pathOr<\n  T,\n  A extends keyof Pathable<T>,\n  B extends keyof Pathable1<T, A>,\n  C extends keyof Pathable2<T, A, B>,\n>(\n  path: readonly [A, B, C],\n  defaultValue: PathValue3<T, A, B, C>,\n): (object: T) => PathValue3<T, A, B, C>;\n\n// TODO [>2]: Remove this function!\nexport function pathOr(...args: ReadonlyArray<unknown>): unknown {\n  return purry(pathOrImplementation, args);\n}\n\nfunction pathOrImplementation(\n  data: unknown,\n  path: ReadonlyArray<PropertyKey>,\n  defaultValue: unknown,\n): unknown {\n  let current = data;\n  for (const prop of path) {\n    if (current === null || current === undefined) {\n      break;\n    }\n    current = (current as Record<PropertyKey, unknown>)[prop];\n  }\n\n  return current ?? defaultValue;\n}\n"],"mappings":"wCAgLA,SAAgB,EAAO,GAAG,EAAuC,CAC/D,OAAO,EAAM,EAAsB,EAAK,CAG1C,SAAS,EACP,EACA,EACA,EACS,CACT,IAAI,EAAU,EACd,IAAK,IAAM,KAAQ,EAAM,CACvB,GAAI,GAAY,KACd,MAEF,EAAW,EAAyC,GAGtD,OAAO,GAAW"}