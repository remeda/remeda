{"version":3,"file":"sortBy-D_n9KPlG.js","names":[],"sources":["../src/sortBy.ts"],"sourcesContent":["import { purryOrderRules, type OrderRule } from \"./internal/purryOrderRules\";\nimport type { CompareFunction } from \"./internal/types/CompareFunction\";\nimport type { IterableContainer } from \"./internal/types/IterableContainer\";\nimport type { NonEmptyArray } from \"./internal/types/NonEmptyArray\";\nimport type { ReorderedArray } from \"./internal/types/ReorderedArray\";\n\n/**\n * Sorts `data` using the provided ordering rules. The `sort` is done via the\n * native `Array.prototype.sort` but is performed on a shallow copy of the array\n * to avoid mutating the original data.\n *\n * There are several other functions that take order rules and **bypass** the\n * need to sort the array first (in *O(nlogn)* time):\n * * `firstBy` === `first(sortBy(data, ...rules))`, O(n).\n * * `takeFirstBy` === `take(sortBy(data, ...rules), k)`, O(nlogk).\n * * `dropFirstBy` === `drop(sortBy(data, ...rules), k)`, O(nlogk).\n * * `nthBy` === `sortBy(data, ...rules).at(k)`, O(n).\n * * `rankBy` === `sortedIndex(sortBy(data, ...rules), item)`, O(n).\n * Refer to the docs for more details.\n *\n * @param sortRules - A variadic array of order rules defining the sorting\n * criteria. Each order rule is a projection function that extracts a comparable\n * value from the data. Sorting is based on these extracted values using the\n * native `<` and `>` operators. Earlier rules take precedence over later ones.\n * Use the syntax `[projection, \"desc\"]` for descending order.\n * @returns A shallow copy of the input array sorted by the provided rules.\n * @signature\n *    R.sortBy(...rules)(data)\n * @example\n *    R.pipe(\n *      [{ a: 1 }, { a: 3 }, { a: 7 }, { a: 2 }],\n *      R.sortBy(R.prop('a')),\n *    ); // => [{ a: 1 }, { a: 2 }, { a: 3 }, { a: 7 }]\n * @dataLast\n * @category Array\n */\nexport function sortBy<T extends IterableContainer>(\n  ...sortRules: Readonly<NonEmptyArray<OrderRule<T[number]>>>\n): (array: T) => ReorderedArray<T>;\n\n/**\n * Sorts `data` using the provided ordering rules. The `sort` is done via the\n * native `Array.prototype.sort` but is performed on a shallow copy of the array\n * to avoid mutating the original data.\n *\n * There are several other functions that take order rules and **bypass** the\n * need to sort the array first (in *O(nlogn)* time):\n * * `firstBy` === `first(sortBy(data, ...rules))`, O(n).\n * * `takeFirstBy` === `take(sortBy(data, ...rules), k)`, O(nlogk).\n * * `dropFirstBy` === `drop(sortBy(data, ...rules), k)`, O(nlogk).\n * * `nthBy` === `sortBy(data, ...rules).at(k)`, O(n).\n * * `rankBy` === `sortedIndex(sortBy(data, ...rules), item)`, O(n).\n * Refer to the docs for more details.\n *\n * @param array - The input array.\n * @param sortRules - A variadic array of order rules defining the sorting\n * criteria. Each order rule is a projection function that extracts a comparable\n * value from the data. Sorting is based on these extracted values using the\n * native `<` and `>` operators. Earlier rules take precedence over later ones.\n * Use the syntax `[projection, \"desc\"]` for descending order.\n * @returns A shallow copy of the input array sorted by the provided rules.\n * @signature\n *    R.sortBy(data, ...rules)\n * @example\n *    R.sortBy(\n *      [{ a: 1 }, { a: 3 }, { a: 7 }, { a: 2 }],\n *      prop('a'),\n *    );  // => [{ a: 1 }, { a: 2 }, { a: 3 }, { a: 7 }]\n *    R.sortBy(\n *      [\n *        {color: 'red', weight: 2},\n *        {color: 'blue', weight: 3},\n *        {color: 'green', weight: 1},\n *        {color: 'purple', weight: 1},\n *      ],\n *      [prop('weight'), 'asc'],\n *      prop('color'),\n *    ); // => [\n *    //   {color: 'green', weight: 1},\n *    //   {color: 'purple', weight: 1},\n *    //   {color: 'red', weight: 2},\n *    //   {color: 'blue', weight: 3},\n *    // ]\n * @dataFirst\n * @category Array\n */\nexport function sortBy<T extends IterableContainer>(\n  array: T,\n  ...sortRules: Readonly<NonEmptyArray<OrderRule<T[number]>>>\n): ReorderedArray<T>;\n\nexport function sortBy(...args: ReadonlyArray<unknown>): unknown {\n  return purryOrderRules(sortByImplementation, args);\n}\n\nconst sortByImplementation = <T>(\n  data: ReadonlyArray<T>,\n  compareFn: CompareFunction<T>,\n): Array<T> =>\n  // TODO [>2]: When node 18 reaches end-of-life bump target lib to ES2023+ and use `Array.prototype.toSorted` here.\n  [...data].sort(compareFn);\n"],"mappings":"kDA2FA,SAAgB,EAAO,GAAG,EAAuC,CAC/D,OAAO,EAAgB,EAAsB,EAAK,CAGpD,MAAM,GACJ,EACA,IAGA,CAAC,GAAG,EAAK,CAAC,KAAK,EAAU"}