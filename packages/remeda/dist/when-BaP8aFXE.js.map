{"version":3,"file":"when-BaP8aFXE.js","names":[],"sources":["../src/when.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any --\n * function inference is stricter and doesn't work well when the arguments\n * aren't typed as `any` in the generic type declaration.\n */\n\nimport type { GuardType } from \"./internal/types/GuardType\";\n\n/**\n * Conditionally run a function based on a predicate, returning it's result (similar to\n * the [`?:` (ternary) operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator).)\n * If the optional `onFalse` function is not provided, the data will be passed\n * through in those cases.\n *\n * Supports type predicates to refine the types for both branches and the return\n * value.\n *\n * Additional arguments are passed to all functions. In data-first calls, they\n * are taken as variadic arguments; but in data-last calls, they are when the\n * curried function itself is called.\n *\n * For more complex cases check out `conditional`.\n *\n * @param predicate - Decides if the `onTrue` mapper should run or not. If it's\n * a type predicate it also narrows types for the mappers and the return value.\n * @param onTrue - Function to run when the predicate returns `true`.\n * @signature\n *   when(predicate, onTrue)(data, ...extraArgs)\n *   when(predicate, { onTrue, onFalse })(data, ...extraArgs)\n * @example\n *   pipe(data, when(isNullish, constant(42)));\n *   pipe(data, when((x) => x > 3, { onTrue: add(1), onFalse: multiply(2) }));\n *   map(data, when(isNullish, (x, index) => x + index));\n * @dataLast\n * @category Function\n */\nexport function when<\n  T,\n  ExtraArgs extends Array<any>,\n  Predicate extends (data: T, ...extraArgs: ExtraArgs) => boolean,\n  OnTrue extends (\n    data: GuardType<Predicate, T>,\n    ...extraArgs: ExtraArgs\n  ) => unknown,\n>(\n  predicate: Predicate,\n  onTrue: OnTrue,\n): (\n  data: T,\n  ...extraArgs: ExtraArgs\n) => Exclude<T, GuardType<Predicate>> | ReturnType<OnTrue>;\nexport function when<\n  T,\n  ExtraArgs extends Array<any>,\n  Predicate extends (data: T, ...extraArgs: ExtraArgs) => boolean,\n  OnTrue extends (\n    data: GuardType<Predicate, T>,\n    ...extraArgs: ExtraArgs\n  ) => unknown,\n  OnFalse extends (\n    data: Exclude<T, GuardType<Predicate>>,\n    ...extraArgs: ExtraArgs\n  ) => unknown,\n>(\n  predicate: Predicate,\n  branches: {\n    readonly onTrue: OnTrue;\n    readonly onFalse: OnFalse;\n  },\n): (\n  data: T,\n  ...extraArgs: ExtraArgs\n) => ReturnType<OnFalse> | ReturnType<OnTrue>;\n\n/**\n * Conditionally run a function based on a predicate, returning it's result (similar to\n * the [`?:` (ternary) operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator).)\n * If the optional `onFalse` function is not provided, the data will be passed\n * through in those cases.\n *\n * Supports type predicates to refine the types for both branches and the return\n * value.\n *\n * Additional arguments are passed to all functions. In data-first calls, they\n * are taken as variadic arguments; but in data-last calls, they are when the\n * curried function itself is called.\n *\n * For more complex cases check out `conditional`.\n *\n * @param data - The data to be passed to all functions, as the first param.\n * @param predicate - Decides if the `onTrue` mapper should run or not. If it's\n * a type predicate it also narrows types for the mappers and the return value.\n * @param onTrue - The function that would run when the predicate returns\n * `true`.\n * @param extraArgs - Additional arguments. These would be passed as is to the\n * `predicate`, `onTrue`, and `onFalse` functions.\n * @signature\n *   when(data, predicate, onTrue, ...extraArgs)\n *   when(data, predicate, { onTrue, onFalse }, ...extraArgs)\n * @example\n *   when(data, isNullish, constant(42));\n *   when(data, (x) => x > 3, { onTrue: add(1), onFalse: multiply(2) });\n *   when(data, isString, (x, radix) => parseInt(x, radix), 10);\n * @dataFirst\n * @category Function\n */\nexport function when<\n  T,\n  ExtraArgs extends Array<any>,\n  Predicate extends (data: T, ...extraArgs: ExtraArgs) => boolean,\n  OnTrue extends (\n    data: GuardType<Predicate, T>,\n    ...extraArgs: ExtraArgs\n  ) => unknown,\n>(\n  data: T,\n  predicate: Predicate,\n  onTrue: OnTrue,\n  ...extraArgs: ExtraArgs\n): Exclude<T, GuardType<Predicate>> | ReturnType<OnTrue>;\nexport function when<\n  T,\n  ExtraArgs extends Array<any>,\n  Predicate extends (data: T, ...extraArgs: ExtraArgs) => boolean,\n  OnTrue extends (\n    data: GuardType<Predicate, T>,\n    ...extraArgs: ExtraArgs\n  ) => unknown,\n  OnFalse extends (\n    data: Exclude<T, GuardType<Predicate>>,\n    ...extraArgs: ExtraArgs\n  ) => unknown,\n>(\n  data: T,\n  predicate: Predicate,\n  branches: {\n    readonly onTrue: OnTrue;\n    readonly onFalse: OnFalse;\n  },\n  ...extraArgs: ExtraArgs\n): ReturnType<OnFalse> | ReturnType<OnTrue>;\n\nexport function when(...args: ReadonlyArray<unknown>): unknown {\n  return args.length === 2\n    ? (data: unknown, ...extraArgs: ReadonlyArray<unknown>) =>\n        // @ts-expect-error [ts2556] -- This is OK, we trust our typing of the overloaded functions\n        whenImplementation(data, ...args, ...extraArgs)\n    : // @ts-expect-error [ts2556] -- This is OK, we trust our typing of the overloaded functions\n      whenImplementation(...args);\n}\n\nconst whenImplementation = <\n  T,\n  ExtraArgs extends Array<any>,\n  WhenTrue,\n  WhenFalse,\n>(\n  data: T,\n  predicate: (data: T, ...extraArgs: ExtraArgs) => boolean,\n  onTrueOrBranches:\n    | ((data: T, ...extraArgs: ExtraArgs) => WhenTrue)\n    | {\n        readonly onTrue: (data: T, ...extraArgs: ExtraArgs) => WhenTrue;\n        readonly onFalse: (data: T, ...extraArgs: ExtraArgs) => WhenFalse;\n      },\n  ...extraArgs: ExtraArgs\n): T | WhenFalse | WhenTrue =>\n  predicate(data, ...extraArgs)\n    ? typeof onTrueOrBranches === \"function\"\n      ? onTrueOrBranches(data, ...extraArgs)\n      : onTrueOrBranches.onTrue(data, ...extraArgs)\n    : typeof onTrueOrBranches === \"function\"\n      ? data\n      : onTrueOrBranches.onFalse(data, ...extraArgs);\n"],"mappings":"AA6IA,SAAgB,EAAK,GAAG,EAAuC,CAC7D,OAAO,EAAK,SAAW,GAClB,EAAe,GAAG,IAEjB,EAAmB,EAAM,GAAG,EAAM,GAAG,EAAU,CAEjD,EAAmB,GAAG,EAAK,CAGjC,MAAM,GAMJ,EACA,EACA,EAMA,GAAG,IAEH,EAAU,EAAM,GAAG,EAAU,CACzB,OAAO,GAAqB,WAC1B,EAAiB,EAAM,GAAG,EAAU,CACpC,EAAiB,OAAO,EAAM,GAAG,EAAU,CAC7C,OAAO,GAAqB,WAC1B,EACA,EAAiB,QAAQ,EAAM,GAAG,EAAU"}