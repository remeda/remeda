{"version":3,"file":"chunk-CVcwgbDh.js","names":[],"sources":["../src/chunk.ts"],"sourcesContent":["import type {\n  IntRange,\n  IsNever,\n  IsNumericLiteral,\n  LessThan,\n  Subtract,\n  ValueOf,\n} from \"type-fest\";\nimport type { IntRangeInclusive } from \"./internal/types/IntRangeInclusive\";\nimport type { IterableContainer } from \"./internal/types/IterableContainer\";\nimport type { NTuple } from \"./internal/types/NTuple\";\nimport type { NonEmptyArray } from \"./internal/types/NonEmptyArray\";\nimport type { PartialArray } from \"./internal/types/PartialArray\";\nimport type { TupleParts } from \"./internal/types/TupleParts\";\nimport { purry } from \"./purry\";\n\n// This prevents typescript from failing on complex arrays and large chunks. It\n// allows the typing to remain useful even when very large chunks are needed,\n// without loosing fidelity on smaller ones. It was chosen by trial-and-error,\n// and given some more wiggle room because the complexity of the array also\n// plays a role in when typescript fails to recurse.\n// See the type tests for an example.\ntype MAX_LITERAL_SIZE = 350;\n\ntype Chunk<\n  T extends IterableContainer,\n  N extends number,\n> = T extends readonly []\n  ? []\n  : IsNumericLiteral<N> extends true\n    ? LessThan<N, 1> extends true\n      ? never\n      : LessThan<N, MAX_LITERAL_SIZE> extends true\n        ? // The spread here is used as a form of \"Simplify\" for arrays; without\n          // it our return type isn't useful.\n          [...LiteralChunk<T, N>]\n        : GenericChunk<T>\n    : GenericChunk<T>;\n\ntype LiteralChunk<T extends IterableContainer, N extends number> =\n  | ChunkRestElement<\n      // Our result will always have the prefix tuple chunked the same way, so\n      // we compute it once here and send it to the main logic below\n      ChunkFixedTuple<TuplePrefix<T>, N>,\n      TupleParts<T>[\"item\"],\n      TupleParts<T>[\"suffix\"],\n      N\n    >\n  // If both the prefix and suffix tuples are empty then our input is a simple\n  // array of the form `Array<Item>`. This means it could also be empty, so we\n  // need to add the empty output to our return type.\n  | ([...TuplePrefix<T>, ...TupleParts<T>[\"suffix\"]] extends readonly []\n      ? []\n      : never);\n\n/**\n * This type **only** works if the input array `T` is a fixed tuple. For these\n * inputs the chunked output could be computed as literal finite tuples too.\n */\ntype ChunkFixedTuple<\n  T,\n  N extends number,\n  // Important! Result is initialized with an empty array (and not `[[]]`)\n  // because the result of `chunk` on an empty array is `[]` and not `[[]]`.\n  Result = [],\n> = T extends readonly [infer Head, ...infer Rest]\n  ? // We continue consuming the input tuple recursively item by item.\n    ChunkFixedTuple<\n      Rest,\n      N,\n      Result extends [\n        ...infer Previous extends Array<Array<unknown>>,\n        infer Current extends Array<unknown>,\n      ]\n        ? // We take a look at the last chunk in the result, this is the\n          // \"current\" chunk where new items would be added, all chunks before\n          // it are already full.\n          Current[\"length\"] extends N\n          ? // The current chunk is full, create a new chunk and put Head in it.\n            [...Previous, Current, [Head]]\n          : // The current chunk is not full yet, so we add Head to it.\n            [...Previous, [...Current, Head]]\n        : // This would only happen on the first iteration, when result is\n          // still empty. In this case we create the first chunk and put Head\n          // in it.\n          [[Head]]\n    >\n  : // We know T is a finite tuple, so the only case where we would reach this\n    // is when T is empty, and in that case our results array contains the whole\n    // input chunked by N.\n    Result;\n\n/**\n * Here lies the main complexity of building the chunk type. It takes the prefix\n * chunks, the rest param item type, and the suffix (not chunked!) and it\n * creates all possible combinations of adding items to the prefix and suffix\n * for all possible scenarios for how many items the rest param \"represents\".\n */\ntype ChunkRestElement<\n  PrefixChunks,\n  Item,\n  Suffix extends Array<unknown>,\n  N extends number,\n> =\n  IsNever<Item> extends true\n    ? // The rest param is never when there is no rest param, the whole array is\n      // a finite tuple and is represented already by the prefix chunks. Suffix\n      // is assumed to be empty in this case.\n      PrefixChunks\n    : PrefixChunks extends [\n          ...infer PrefixFullChunks extends Array<Array<unknown>>,\n          infer LastPrefixChunk extends Array<unknown>,\n        ]\n      ? // When our prefix chunks are not empty it means we need to look at all\n        // combinations of mixing the prefix, the suffix, and different counts\n        // of the rest param until we cover all possible scenarios.\n        | ValueOf<{\n              // We want to iterate over all possible padding sizes we can add\n              // to the last prefix chunk until we reach N\n              // (`0..N-LastPrefixChunk.length`). We need to do this because\n              // until the last prefix chunk is full, we need to consider the\n              // suffix being part of it too...\n              [Padding in IntRangeInclusive<\n                0,\n                Subtract<N, LastPrefixChunk[\"length\"]>\n              >]: [\n                ...PrefixFullChunks,\n                ...ChunkFixedTuple<\n                  // Create a new array that would **not** contain a rest param\n                  // (so it's finite) made of the last prefix chunk, padding\n                  // from the rest param, and the suffix.\n                  [...LastPrefixChunk, ...NTuple<Item, Padding>, ...Suffix],\n                  N\n                >,\n              ];\n            }>\n          // Additionally, we need to consider the case where the last prefix\n          // chunk **is** full, and follow it with an array of chunks of the\n          // rest param (and only them), and then followed by all possible\n          // variations of the suffix chunks.\n          | [\n              ...PrefixFullChunks,\n              [\n                // Fully padded last prefix chunk\n                ...LastPrefixChunk,\n                ...NTuple<Item, Subtract<N, LastPrefixChunk[\"length\"]>>,\n              ],\n              ...Array<NTuple<Item, N>>,\n              ...SuffixChunk<Suffix, Item, N>,\n            ]\n      : // When our prefix chunks are empty we only need to handle the suffix\n        [...Array<NTuple<Item, N>>, ...SuffixChunk<Suffix, Item, N>];\n\n/**\n * This type assumes it takes a finite tuple that represents the suffix of our\n * input array. It builds all possible combinations of adding items to the\n * **head** of the suffix in order to pad the suffix until the last chunk is\n * full.\n */\ntype SuffixChunk<\n  T extends Array<unknown>,\n  Item,\n  N extends number,\n> = T extends readonly []\n  ? // If we don't have a suffix we simply create a single chunk with all\n    // possible non-empty sub-arrays of `Item` up to size `N`.\n    [ValueOf<{ [K in IntRangeInclusive<1, N>]: NTuple<Item, K> }>]\n  : ValueOf<{\n      // When suffix isn't empty we pad the head of the suffix and compute it's\n      // chunks for all possible padding sizes.\n      [Padding in IntRange<0, N>]: ChunkFixedTuple<\n        [...NTuple<Item, Padding>, ...T],\n        N\n      >;\n    }>;\n\n/**\n * This is the legacy type used when we don't know what N is. We can only adjust\n * our output based on if we know for sure that the array is empty or not.\n */\ntype GenericChunk<T extends IterableContainer> = T extends\n  | readonly [...Array<unknown>, unknown]\n  | readonly [unknown, ...Array<unknown>]\n  ? NonEmptyArray<NonEmptyArray<T[number]>>\n  : Array<NonEmptyArray<T[number]>>;\n\n// TODO: Chunk was built before we handled optional elements correctly. It needs to be fixed to handle these correctly, specifically in regard to optional elements creating whole chunks that themselves need to be optional, but that their items themselves should not be optional, except the last chunk...\ntype TuplePrefix<T extends IterableContainer> = [\n  ...TupleParts<T>[\"required\"],\n  ...PartialArray<TupleParts<T>[\"optional\"]>,\n];\n\n/**\n * Split an array into groups the length of `size`. If `array` can't be split evenly, the final chunk will be the remaining elements.\n *\n * @param array - The array.\n * @param size - The length of the chunk.\n * @signature\n *    R.chunk(array, size)\n * @example\n *    R.chunk(['a', 'b', 'c', 'd'], 2) // => [['a', 'b'], ['c', 'd']]\n *    R.chunk(['a', 'b', 'c', 'd'], 3) // => [['a', 'b', 'c'], ['d']]\n * @dataFirst\n * @category Array\n */\nexport function chunk<T extends IterableContainer, N extends number>(\n  array: T,\n  size: N,\n): Chunk<T, N>;\n\n/**\n * Split an array into groups the length of `size`. If `array` can't be split evenly, the final chunk will be the remaining elements.\n *\n * @param size - The length of the chunk.\n * @signature\n *    R.chunk(size)(array)\n * @example\n *    R.chunk(2)(['a', 'b', 'c', 'd']) // => [['a', 'b'], ['c', 'd']]\n *    R.chunk(3)(['a', 'b', 'c', 'd']) // => [['a', 'b', 'c'], ['d']]\n * @dataLast\n * @category Array\n */\nexport function chunk<N extends number>(\n  size: N,\n): <T extends IterableContainer>(array: T) => Chunk<T, N>;\n\nexport function chunk(...args: ReadonlyArray<unknown>): unknown {\n  return purry(chunkImplementation, args);\n}\n\nfunction chunkImplementation<T>(\n  data: ReadonlyArray<T>,\n  size: number,\n): Array<Array<T>> {\n  if (size < 1) {\n    throw new RangeError(\n      `chunk: A chunk size of '${size.toString()}' would result in an infinite array`,\n    );\n  }\n\n  if (data.length === 0) {\n    return [];\n  }\n\n  if (size >= data.length) {\n    // Optimized for when there is only one chunk.\n    return [[...data]];\n  }\n\n  const chunks = Math.ceil(data.length / size);\n\n  // eslint-disable-next-line unicorn/no-new-array -- This is OK, a sparse array allows us to handle very large arrays more efficiently.\n  const result = new Array<Array<T>>(chunks);\n\n  if (size === 1) {\n    // Optimized for when we don't need slice.\n    for (const [index, item] of data.entries()) {\n      result[index] = [item];\n    }\n  } else {\n    for (let index = 0; index < chunks; index += 1) {\n      const start = index * size;\n      result[index] = data.slice(start, start + size);\n    }\n  }\n\n  return result;\n}\n"],"mappings":"wCAkOA,SAAgB,EAAM,GAAG,EAAuC,CAC9D,OAAO,EAAM,EAAqB,EAAK,CAGzC,SAAS,EACP,EACA,EACiB,CACjB,GAAI,EAAO,EACT,MAAU,WACR,2BAA2B,EAAK,UAAU,CAAC,qCAC5C,CAGH,GAAI,EAAK,SAAW,EAClB,MAAO,EAAE,CAGX,GAAI,GAAQ,EAAK,OAEf,MAAO,CAAC,CAAC,GAAG,EAAK,CAAC,CAGpB,IAAM,EAAS,KAAK,KAAK,EAAK,OAAS,EAAK,CAGtC,EAAa,MAAgB,EAAO,CAE1C,GAAI,IAAS,EAEX,IAAK,GAAM,CAAC,EAAO,KAAS,EAAK,SAAS,CACxC,EAAO,GAAS,CAAC,EAAK,MAGxB,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAQ,GAAS,EAAG,CAC9C,IAAM,EAAQ,EAAQ,EACtB,EAAO,GAAS,EAAK,MAAM,EAAO,EAAQ,EAAK,CAInD,OAAO"}