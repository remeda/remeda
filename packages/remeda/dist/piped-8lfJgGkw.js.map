{"version":3,"file":"piped-8lfJgGkw.js","names":[],"sources":["../src/piped.ts"],"sourcesContent":["import { pipe } from \"./pipe\";\n\n/**\n * Data-last version of `pipe`. See `pipe` documentation for full details.\n *\n * Use `piped` when you need to pass a transformation as a callback to\n * functions like `map` and `filter`, where the data type can be inferred\n * from the call site.\n *\n * IMPORTANT: `piped` does not work as a \"function factory\" in order to create\n * standalone utility functions; because TypeScript cannot infer the input data\n * type (without requiring to explicitly define all type params for all\n * functions in the pipe). We recommend defining the function explicitly, and\n * then use `pipe` in its implementation.\n *\n * @signature\n *    R.piped(...functions)(data);\n * @example\n *    R.map(\n *      [{ a: 1 }, { a: 2 }, { a: 3 }],\n *      R.piped(R.prop('a'), R.add(1)),\n *    ); //=> [2, 3, 4]\n * @dataLast\n * @category Function\n */\nexport function piped<A>(): (data: A) => A;\n\nexport function piped<A, B>(funcA: (input: A) => B): (data: A) => B;\n\nexport function piped<A, B, C>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n): (data: A) => C;\n\nexport function piped<A, B, C, D>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n): (data: A) => D;\n\nexport function piped<A, B, C, D, E>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n): (data: A) => E;\n\nexport function piped<A, B, C, D, E, F>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n  funcE: (input: E) => F,\n): (data: A) => F;\n\nexport function piped<A, B, C, D, E, F, G>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n  funcE: (input: E) => F,\n  funcF: (input: F) => G,\n): (data: A) => G;\n\nexport function piped<A, B, C, D, E, F, G, H>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n  funcE: (input: E) => F,\n  funcF: (input: F) => G,\n  funcG: (input: G) => H,\n): (data: A) => H;\n\nexport function piped<A, B, C, D, E, F, G, H, I>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n  funcE: (input: E) => F,\n  funcF: (input: F) => G,\n  funcG: (input: G) => H,\n  funcH: (input: H) => I,\n): (data: A) => I;\n\nexport function piped<A, B, C, D, E, F, G, H, I, J>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n  funcE: (input: E) => F,\n  funcF: (input: F) => G,\n  funcG: (input: G) => H,\n  funcH: (input: H) => I,\n  funcI: (input: I) => J,\n): (data: A) => J;\n\nexport function piped<A, B, C, D, E, F, G, H, I, J, K>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n  funcE: (input: E) => F,\n  funcF: (input: F) => G,\n  funcG: (input: G) => H,\n  funcH: (input: H) => I,\n  funcI: (input: I) => J,\n  funcJ: (input: J) => K,\n): (data: A) => K;\n\nexport function piped<A, B, C, D, E, F, G, H, I, J, K, L>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n  funcE: (input: E) => F,\n  funcF: (input: F) => G,\n  funcG: (input: G) => H,\n  funcH: (input: H) => I,\n  funcI: (input: I) => J,\n  funcJ: (input: J) => K,\n  funcK: (input: K) => L,\n): (data: A) => L;\n\nexport function piped<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n  funcE: (input: E) => F,\n  funcF: (input: F) => G,\n  funcG: (input: G) => H,\n  funcH: (input: H) => I,\n  funcI: (input: I) => J,\n  funcJ: (input: J) => K,\n  funcK: (input: K) => L,\n  funcL: (input: L) => M,\n): (data: A) => M;\n\nexport function piped<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n  funcE: (input: E) => F,\n  funcF: (input: F) => G,\n  funcG: (input: G) => H,\n  funcH: (input: H) => I,\n  funcI: (input: I) => J,\n  funcJ: (input: J) => K,\n  funcK: (input: K) => L,\n  funcL: (input: L) => M,\n  funcM: (input: M) => N,\n): (data: A) => N;\n\nexport function piped<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n  funcE: (input: E) => F,\n  funcF: (input: F) => G,\n  funcG: (input: G) => H,\n  funcH: (input: H) => I,\n  funcI: (input: I) => J,\n  funcJ: (input: J) => K,\n  funcK: (input: K) => L,\n  funcL: (input: L) => M,\n  funcM: (input: M) => N,\n  funcN: (input: N) => O,\n): (data: A) => O;\n\nexport function piped<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  funcA: (input: A) => B,\n  funcB: (input: B) => C,\n  funcC: (input: C) => D,\n  funcD: (input: D) => E,\n  funcE: (input: E) => F,\n  funcF: (input: F) => G,\n  funcG: (input: G) => H,\n  funcH: (input: H) => I,\n  funcI: (input: I) => J,\n  funcJ: (input: J) => K,\n  funcK: (input: K) => L,\n  funcL: (input: L) => M,\n  funcM: (input: M) => N,\n  funcN: (input: N) => O,\n  funcO: (input: O) => P,\n): (data: A) => P;\n\nexport function piped(\n  ...functions: ReadonlyArray<(input: unknown) => unknown>\n) {\n  return (value: unknown): unknown =>\n    pipe(\n      value,\n      // @ts-expect-error [ts2556] - We can't avoid this error because pipe is typed for users and this is an internal function\n      ...functions,\n    );\n}\n"],"mappings":"uCA8LA,SAAgB,EACd,GAAG,EACH,CACA,MAAQ,IACN,EACE,EAEA,GAAG,EACJ"}