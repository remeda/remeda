---
import { Code } from "astro:components";
import Layout from "@/layouts/layout.astro";
import { CopyButton } from "@/components/copy-button";

const commands = [
  "npm install remeda",
  "pnpm add remeda",
  "yarn add remeda",
  "bun install remeda",
];
---

<Layout>
  <main class="flex flex-col gap-6 py-20">
    <h1 class="text-3xl font-bold md:text-5xl">Remeda</h1>

    <p class="mt-2 max-w-prose text-muted-foreground sm:text-lg">
      The first "data-first" and "data-last" utility library designed
      specifically for TypeScript
    </p>

    <div class="flex flex-col gap-2">
      {
        commands.map((command) => (
          <div class="relative w-80">
            <Code code={command} lang="bash" theme="poimandres" />

            <div class="absolute right-2 top-1/2 -translate-y-1/2">
              <CopyButton value={command} client:load />
            </div>
          </div>
        ))
      }
    </div>

    <h2 class="mt-10 text-2xl font-bold md:text-3xl">Why?</h2>

    <p class="max-w-prose text-muted-foreground sm:text-lg">
      There are no good utility libraries that work well with TypeScript. When
      working with Lodash or Ramda you have to annotate types manually most of
      the time. Remeda is written and tested in TypeScript and that means there
      won't be any problems with custom typings.
    </p>

    <h2 class="mt-10 text-2xl font-bold md:text-3xl">
      What's "data-first" and "data-last"?
    </h2>

    <p class="max-w-prose text-muted-foreground sm:text-lg">
      Functional programming is nice, and it makes the code more readable.
      However there are situations where you don't need "pipes", and you want to
      call just a single function.
    </p>

    <div class="max-w-5xl">
      <Code
        code=`
// Remeda
R.pick(obj, ['firstName', 'lastName']);

// Ramda
R.pick(['firstName', 'lastName'], obj);

// Lodash
_.pick(obj, ['firstName', 'lastName']);`
        lang="js"
        theme="poimandres"
      />
    </div>

    <p class="max-w-prose text-muted-foreground sm:text-lg">
      For readers looking for data-last forms like
      <code>R.filter(fn)(array)</code>, Remeda supports it. Keep reading along!
    </p>

    <p class="max-w-prose text-muted-foreground sm:text-lg">
      In the above example, "data-first" approach is more natural and more
      programmer friendly because when you type the second argument, you get the
      auto-complete from the IDE. It's not possible to get the auto-complete in
      Ramda because the data argument is not provided.
    </p>

    <p class="max-w-prose text-muted-foreground sm:text-lg">
      "data-last" approach is helpful when writing data transformations aka
      pipes.
    </p>

    <div class="max-w-5xl">
      <Code
        code=`
const users = [
  {name: 'john', age: 20, gender: 'm'},
  {name: 'marry', age: 22, gender: 'f'},
  {name: 'samara', age: 24, gender: 'f'},
  {name: 'paula', age: 24, gender: 'f'},
  {name: 'bill', age: 33, gender: 'm'},
]

// Remeda
R.pipe(
  users,
  R.filter(x => x.gender === 'f'),
  R.groupBy(x => x.age),
);

// Ramda
R.pipe(
  R.filter(x => x.gender === 'f'),
  R.groupBy(x => x.age),
)(users) // broken typings in TS :(

// Lodash
_(users)
  .filter(x => x.gender === 'f')
  .groupBy(x => x.age)
  .value()

// Lodash-fp
_.flow(
  _.filter(x => x.gender === 'f'),
  _.groupBy(x => x.age),
)(users)// broken typings in TS :(`
        lang="js"
        theme="poimandres"
      />
    </div>

    <p class="max-w-prose text-muted-foreground sm:text-lg">
      Mixing paradigms can be cumbersome in Lodash because it requires importing
      two different methods. Remeda implements all methods in two versions, and
      the correct overload is picked based on the number of provided arguments.
      The "data-last" version must always have one argument less than the
      "data-first" version.
    </p>

    <div class="max-w-5xl">
      <Code
        code=`
// Remeda
R.pick(obj, ['firstName', 'lastName']); // data-first
R.pipe(obj, R.pick(['firstName', 'lastName'])); // data-last

R.pick(['firstName', 'lastName'], obj); // error, this won't work!
R.pick(['firstName', 'lastName'])(obj); // this will work but the types cannot be inferred`
        lang="js"
        theme="poimandres"
      />
    </div>

    <h2 class="mt-10 text-2xl font-bold md:text-3xl">Lazy evaluation</h2>

    <p class="max-w-prose text-muted-foreground sm:text-lg">
      Many functions support lazy evaluation when using <code>pipe</code> or <code
        >createPipe</code
      >. These functions have a <code>pipeable</code> tag in the documentation.
    </p>

    <p class="max-w-prose text-muted-foreground sm:text-lg">
      Lazy evaluation is not supported in Ramda and only partially supported in
      lodash.
    </p>

    <div class="max-w-5xl">
      <Code
        code=`
// Get first 3 unique values
const arr = [1, 2, 2, 3, 3, 4, 5, 6];

const result = R.pipe(
  arr,
  R.map(x => {
    console.log('iterate', x);
    return x;
  }),
  R.uniq(),
  R.take(3)
); // => [1, 2, 3]

/**
 * Console output:
 * iterate 1
 * iterate 2
 * iterate 2
 * iterate 3
 * /`
        lang="js"
        theme="poimandres"
      />
    </div>

    <h2 class="mt-10 text-2xl font-bold md:text-3xl">Indexed version</h2>

    <p class="max-w-prose text-muted-foreground sm:text-lg">
      Iterable functions have an extra property <code>indexed</code> which is the
      same function with iterator <code>(element, index, array)</code>.
    </p>

    <div class="max-w-5xl">
      <Code
        code=`
const arr = [10, 12, 13, 3];

// filter even values
R.filter(arr, x => x % 2 === 0); // => [10, 12]

// filter even indexes
R.filter.indexed(arr, (x, i) => i % 2 === 0); // => [10, 13]`
        lang="js"
        theme="poimandres"
      />
    </div>

    <h2 class="mt-10 text-2xl font-bold md:text-3xl">Strict version</h2>

    <p class="max-w-prose text-muted-foreground sm:text-lg">
      Some functions have an extra property <code>strict</code> which is the same
      function with stricter types.
    </p>

    <div class="max-w-5xl">
      <Code
        code=`
const input = { a: 'x', b: 'y', c: 'z' } as const

const result = R.keys(input)
// ^? Array<string>

const resultStrict = R.keys.strict(input)
// ^? Array<'a' | 'b' | 'c'>`
        lang="js"
        theme="poimandres"
      />
    </div>
  </main>
</Layout>
